### 组件通讯常用方式

#### props

父给子传值 自定义事件

```js
 // child 
props: { msg: String } 

// parent
<HelloWorld msg="Welcome to Your Vue.js App"/>
```

#### 自定义事件

子给父传值

```js
// child
this.$emit('add', good)
// parent
<Cart @add="cartAdd($event)"></Cart>
```

#### 事件总线

任意两个组件之间传值常用事件总线 或 vuex的方式

```js
// Bus：事件派发、监听和回调管理
// 其实就是实现了$on和$emit两个接口以及回调收集起来，典型的发布订阅模式，通常事件派发者和监听者是同一个
class Bus {
  constructor(){
    this.callbacks = {}
  }

  $on(name, fn){
    this.callbacks[name] = this.callbacks[name] || []
    this.callbacks[name].push(fn)
  }

  $emit(name, args){
    if(this.callbacks[name]){
      this.callbacks[name].forEach(cb => cb(args))
    }
  }
}

// main.js
Vue.prototype.$bus = new Bus()

// child1
this.$bus.$on('foo', handle)

// child2
this.$bus.$emit('foo')
```

> 实践中通常用Vue代替Bus，因为Vue已经实现了相应接口

#### vuex

创建唯一的全局数据管理者store，通过它管理数据并通知自建状态变更

**下面是不太常用的一些边界情况，但开发通用组件时会用到，因为要兼容更多Vue实例，并不是每个实例都有总线或者vuex**

#### $parent/$root

兄弟组件之间通信可通过共同祖辈搭桥，$parent或$root。

```js
// 其实和总线异曲同工
// brother1
this.$parent.$on('foo', handle)
// brother2
this.$parent.$emit('foo')
```

#### $children

父组件可以通过$children访问子组件实现父子通信。

```js
// parent
this.$children[0].xx = 'xxx'
```

> 注意：$children不能保证子元素顺序，例如出现异步组件时是异步方式加载进来的，虽然声明时顺序在前面，但注册到children时的位置是在后面的

#### $attrs/$listeners

**$attrs**

包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件——在创建高级别的组件时非常有用。

简单点讲就是包含了所以父组件在子组件上设置的属性（除了`prop`传递的属性、`class` 和 `style` ）。

```js
// child：并未在props中声明foo
<p>{{$attrs.foo}}</p>
// parent
<HelloWorld foo="foo"/>
```

**$listeners**

包含了父作用域中的 (不含 `.native` 修饰器的) `v-on` 事件监听器。它可以通过 `v-on="$listeners"` 传入内部组件——在创建更高层次的组件时非常有用。

简单点讲它是一个对象，里面包含了作用在这个组件上所有的监听器（监听事件），可以通过 `v-on="$listeners"` 将事件监听指向这个组件内的子元素（包括内部的子组件）。

允许在祖辈组件中处理子孙组件的监听。

```js
// parent
<parent @click="onClick"></parent>

methods: {
  onClick() {
    // do some in parent
    // 这里的this也是父组件
  }
}

// children
// $listeners会被展开并监听
<children v-on="$listeners"></children>
// 注意不能用@
// <children @click="$listeners"></children>
```

#### refs

获取子节点引用

```js
// parent
<HelloWorld ref="hw"/>
mounted() {
  this.$refs.hw.xx = 'xxx'
}
```

#### provide/inject

> `provide` 和 `inject` 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。

这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，**不论组件层次有多深**，并在其上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。

`provide` 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的 property。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 `Symbol` 和 `Reflect.ownKeys` 的环境下可工作。

注意：inject进来的数据是没有响应式的

`inject` 选项应该是：

- 一个字符串数组，或
- 一个对象，对象的 key 是本地的绑定名，value 是：
  - 在可用的注入内容中搜索用的 key (字符串或 Symbol)，或
  - 一个对象，该对象的：
    - `from` property 是在可用的注入内容中搜索用的 key (字符串或 Symbol)
    - `default` property 是降级情况下使用的 value

```js
// 父级组件提供 'foo'
var Provider = {
  provide: {
    foo: 'foo'
  },
  // ...
}

// 子组件注入 'foo'
var Child = {
  inject: ['foo'],
  /* or
  父组件和子组件使用不是同一个key的时候
  inject: {
    bar: {from: 'foo'}
  },
  */

  created () {
    console.log(this.foo) // => "foo"
    // console.log(this.bar) // => "foo"
  }
  // ...
}
```

利用 ES2015 Symbols、函数 `provide` 和对象 `inject`：

```js
const s = Symbol()

const Provider = {
  provide () {
    return {
      [s]: 'foo'
    }
  }
}

const Child = {
  inject: { s },
  // ...
}
```

